# -*- coding: utf-8 -*-
"""Seminario.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rWZmnEFsUPuwGRk3Z3wMrGw39iC4xwXS
"""

import numpy as np
import pandas as pd
import yfinance as yf
import cvxpy as cp
from scipy.stats import skew, kurtosis, norm
import scipy.optimize as op
from tqdm import tqdm
import matplotlib.pyplot as plt
import datetime
import warnings
from typing import List, Tuple, Dict, Optional
import streamlit as st
import plotly.express as px


# Desactivar warnings
warnings.filterwarnings("ignore")

# --------------------- UNIVERSO -----------------------
universo = {
    "regions": {
        "tickers": ["SPLG", "EWC", "IEUR", "EEM", "EWJ"],
        "weights": np.array([0.7062, 0.0323, 0.1176, 0.0902, 0.0537])
    },
    "sectors": {
        "tickers": ["XLC","XLY","XLP","XLE","XLF","XLV","XLI","XLB","XLRE","XLK","XLU"],
        "weights": np.array([0.0999,0.1025,0.0482,0.0295,0.1307,0.0958,0.0809,0.0166,0.0187,0.3535,0.0237])
    }
}

# --------------------- DATOS -----------------------
data_regions = yf.download(
    universo["regions"]["tickers"],
    start="2019-01-01",
    end=datetime.date.today().isoformat()
)["Close"]

data_sectors = yf.download(
    universo["sectors"]["tickers"],
    start="2019-01-01",
    end=datetime.date.today().isoformat()
)["Close"]

returns_regions = data_regions.pct_change().dropna()
returns_sectors = data_sectors.pct_change().dropna()

# Par√°metros
rf = 0.109
periodos_a√±o = 252
rf_diaria = (1 + rf)**(1/periodos_a√±o) - 1

benchmark_regions = returns_regions.dot(universo["regions"]["weights"])
benchmark_sectors = returns_sectors.dot(universo["sectors"]["weights"])

def metricas_portafolio(returns, weights, benchmark, rf_diaria, periodos_a√±o=252, target=0.0):

    r = returns.dot(weights)
    excess = r - rf_diaria
    excess_benchmark = benchmark - rf_diaria

    ret_prom = r.mean() * periodos_a√±o
    volatilidad = r.std() * np.sqrt(periodos_a√±o)

    sesgo = r.skew()
    curtosis = r.kurtosis()

    var_95 = r.quantile(0.05)
    cvar_95 = r[r <= var_95].mean()

    sharpe = np.sqrt(periodos_a√±o) * excess.mean() / excess.std()

    downside = r[r < target] - target
    downside_std = np.sqrt(np.mean(downside**2))
    sortino = np.sqrt(periodos_a√±o) * excess.mean() / downside_std

    curva = (1 + r).cumprod()
    max_dd = (curva / curva.cummax() - 1).min()

    cov = np.cov(excess, excess_benchmark)[0,1]
    beta = cov / excess_benchmark.var()
    corr = np.corrcoef(r, excess_benchmark)[0,1]

    treynor = excess.mean()*periodos_a√±o / beta

    active = r - benchmark
    ir = np.sqrt(periodos_a√±o) * active.mean() / active.std()

    cumulative = (1+r).cumprod()
    cagr = cumulative.iloc[-1]**(periodos_a√±o/len(r)) - 1
    calmar = cagr / abs(max_dd)

    return {
        "ret_anual": ret_prom,
        "vol_anual": volatilidad,
        "sharpe": sharpe,
        "sortino": sortino,
        "max_drawdown": max_dd,
        "beta": beta,
        "correlacion": corr,
        "sesgo": sesgo,
        "curtosis": curtosis,
        "VaR_95": var_95,
        "CVaR_95": cvar_95,
        "treynor": treynor,
        "information_ratio": ir,
        "calmar": calmar
    }

def constraint_sum_weights():
    return {'type':'eq', 'fun':lambda w: np.sum(w) - 1}

def minimize_volatility(returns, benchmark, rf_diaria):
    n = returns.shape[1]
    bounds = tuple((0,1) for _ in range(n))
    x0 = np.ones(n)/n

    res = op.minimize(
        lambda w: metricas_portafolio(returns, w, benchmark, rf_diaria)["vol_anual"],
        x0, method="SLSQP", constraints=constraint_sum_weights(), bounds=bounds
    )

    return res.x, metricas_portafolio(returns, res.x, benchmark, rf_diaria)

def maximize_return(returns, benchmark, rf_diaria):
    n = returns.shape[1]
    bounds = tuple((0,1) for _ in range(n))
    x0 = np.ones(n)/n

    res = op.minimize(
        lambda w: -metricas_portafolio(returns, w, benchmark, rf_diaria)["ret_anual"],
        x0, method="SLSQP", constraints=constraint_sum_weights(), bounds=bounds
    )

    return res.x, metricas_portafolio(returns, res.x, benchmark, rf_diaria)

def maximize_sharpe(returns, benchmark, rf_diaria):
    n = returns.shape[1]
    bounds = tuple((0,1) for _ in range(n))
    x0 = np.ones(n)/n

    res = op.minimize(
        lambda w: -metricas_portafolio(returns, w, benchmark, rf_diaria)["sharpe"],
        x0, method="SLSQP", constraints=constraint_sum_weights(), bounds=bounds
    )

    return res.x, metricas_portafolio(returns, res.x, benchmark, rf_diaria)

w_min_reg, met_min_reg = minimize_volatility(returns_regions, benchmark_regions, rf_diaria)
w_min_sec, met_min_sec = minimize_volatility(returns_sectors, benchmark_sectors, rf_diaria)

w_ret_reg, met_ret_reg = maximize_return(returns_regions, benchmark_regions, rf_diaria)
w_ret_sec, met_ret_sec = maximize_return(returns_sectors, benchmark_sectors, rf_diaria)

w_sh_reg, met_sh_reg = maximize_sharpe(returns_regions, benchmark_regions, rf_diaria)
w_sh_sec, met_sh_sec = maximize_sharpe(returns_sectors, benchmark_sectors, rf_diaria)

portafolios = {
    "Regiones - Min Var": met_min_reg,
    "Sectores - Min Var": met_min_sec,
    "Regiones - Max Ret": met_ret_reg,
    "Sectores - Max Ret": met_ret_sec,
    "Regiones - Max Sharpe": met_sh_reg,
    "Sectores - Max Sharpe": met_sh_sec,
}

map_metric = {
    "retorno": "ret_anual",
    "vol": "vol_anual",
    "sharpe": "sharpe",
    "sortino": "sortino",
    "mdd": "max_drawdown",
}

metrics = portafolios

def run_app():

    st.title("Optimizaci√≥n de Portafolio")

    st.markdown("""
    Esta app compara portafolios de **regiones** y **sectores**, calculando m√©tricas clave:

    - **Volatilidad:** mejor entre menor.
    - **Retorno anualizado:** mejor entre mayor.
    - **Sharpe ratio:** retorno ajustado al riesgo, mejor entre mayor.
    - **M√°ximo drawdown:** menor p√©rdida m√°xima.
    - **Sortino ratio:** versi√≥n de Sharpe basada solo en ca√≠das.

    Selecciona una m√©trica y los portafolios a comparar.
    """)

    metric = st.selectbox(
        "Selecciona la m√©trica a graficar:",
        ["retorno", "vol", "sharpe", "sortino", "mdd"]
    )

    port_names = list(portafolios.keys())

    selected = st.multiselect(
        "Selecciona los portafolios a comparar:",
        port_names,
        default=port_names
    )

    # --------- GR√ÅFICA ----------
    clave = map_metric[metric]
    valores = {p: metrics[p][clave] for p in selected}

    fig = px.bar(
        x=list(valores.keys()),
        y=list(valores.values()),
        labels={"x": "Portafolio", "y": clave},
        title=f"Comparaci√≥n por m√©trica: {clave}"
    )
    st.plotly_chart(fig)

    # --------- MEJOR PORTAFOLIO ----------
    if metric in ["retorno", "sharpe", "sortino"]:
        best = max(valores, key=valores.get)
    else:
        best = min(valores, key=valores.get)

    st.success(f"üìå El mejor portafolio seg√∫n **{metric}** es: **{best}**")

    # --------- PORTAFOLIO DEL USUARIO ----------
    st.subheader("Evaluaci√≥n de tu propio portafolio")

    user_weights = st.text_input(
        "Ingresa tus pesos separados por coma (por ejemplo: 0.2,0.3,0.5):"
    )

    if user_weights:
        try:
            w = np.array([float(x) for x in user_weights.split(",")])
            w /= np.sum(w)

            # Por defecto, basamos el an√°lisis en regiones
            m = metricas_portafolio(returns_regions, w, benchmark_regions, rf_diaria)

            st.write("### M√©tricas de tu portafolio")
            st.json(m)

            fig2 = px.bar(
                x=list(m.keys()),
                y=list(m.values()),
                title="M√©tricas de tu portafolio"
            )
            st.plotly_chart(fig2)

            comment = []
            if m["sharpe"] > np.mean([metrics[p]["sharpe"] for p in port_names]):
                comment.append("‚úîÔ∏è Buen Sharpe ratio.")
            else:
                comment.append("‚ö†Ô∏è Sharpe ratio por debajo del promedio.")

            if m["vol_anual"] < np.mean([metrics[p]["vol_anual"] for p in port_names]):
                comment.append("‚úîÔ∏è Baja volatilidad.")
            else:
                comment.append("‚ö†Ô∏è Volatilidad superior al promedio.")

            st.info("\n".join(comment))

        except:
            st.error("Error al interpretar los pesos. Revisa el formato.")

if __name__ == "__main__":
    run_app()