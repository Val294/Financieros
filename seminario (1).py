# -*- coding: utf-8 -*-
"""Seminario.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rWZmnEFsUPuwGRk3Z3wMrGw39iC4xwXS
"""

import numpy as np
import pandas as pd
import yfinance as yf
import cvxpy as cp
from scipy.stats import skew, kurtosis, norm
import scipy.optimize as op
from tqdm import tqdm
import matplotlib.pyplot as plt
import datetime
import warnings
from typing import List, Tuple, Dict, Optional
import streamlit as st

# Desactivar warnings
warnings.filterwarnings("ignore")

# ---------------------------
# PASO 1: RECOLECCI√ìN DE DATOS
# ---------------------------


# ---------------------------
# Universo
# ---------------------------
universo = {
    "regions": {
        "tickers": ["SPLG", "EWC", "IEUR", "EEM", "EWJ"],
        "weights": np.array([0.7062, 0.0323, 0.1176, 0.0902, 0.0537])
    },
    "sectors": {
        "tickers": ["XLC","XLY","XLP","XLE","XLF","XLV","XLI","XLB","XLRE","XLK","XLU"],
        "weights": np.array([0.0999,0.1025,0.0482,0.0295,0.1307,0.0958,0.0809,0.0166,0.0187,0.3535,0.0237])
    }
}


# ---------------------------
# Descargar datos
# ---------------------------
data_regions = yf.download(universo["regions"]["tickers"], start="2019-01-01", end=datetime.date.today().isoformat())["Close"]
data_sectors = yf.download(universo["sectors"]["tickers"], start="2019-01-01", end=datetime.date.today().isoformat())["Close"]

# Retornos
returns_regions = data_regions.pct_change().dropna()
returns_sectors = data_sectors.pct_change().dropna()


# ---------------------------
# Par√°metros
# ---------------------------
rf = 0.109
periodos_a√±o = 252

rf_diaria = (1 + rf)**(1/periodos_a√±o) - 1

# ---------------------------
# Benchmark
# ---------------------------
benchmark_regions = returns_regions.dot(universo["regions"]["weights"])
benchmark_sectors = returns_sectors.dot(universo["sectors"]["weights"])

# ------------------------
# PASO 2. M√âTRICAS
# ------------------------


def metricas_portafolio(returns: pd.DataFrame,
                        weights: np.ndarray,
                        benchmark: pd.Series,
                        rf_diaria: float,
                        periodos_a√±o: int = 252,
                        target: float = 0.0
                        ) -> dict:
    """
    Calcula las m√©tricas de un portafolio dadas sus series de rendimientos por activo
    y sus pesos.
    """

    # ------------------------
    # 1. Retorno del portafolio
    # ------------------------
    # suma ponderada de rendimientos diarios
    r = returns.dot(weights)

    excess = r - rf_diaria
    excess_benchmark = benchmark - rf_diaria

    metricas = {}

    # ------------------------
    # M√©tricas
    # ------------------------

    # Retorno promedio anualizado
    ret_prom = r.mean() * periodos_a√±o

    # Volatilidad: desviaci√≥n est√°ndar anualizada
    volatilidad = r.std() * np.sqrt(periodos_a√±o)

    # Sesgo: que tan simetrico es. Negativo = cola izquierda = perdidas fuertes
    sesgo = r.skew()

    # Curtosis: que tan pesadas son las colas. Alta = eventos extremos frecuentes
    curtosis = r.kurtosis()

    # VaR 95%
    var_95 = r.quantile(0.05)

    # CVaR 95%
    cvar_95 = r[r <= var_95].mean()


    # Sharpe ratio: rendimiento ajustado al riesgo
    # retornos en exceso = R_p - R_f
    promedio_excess = excess.mean()           # E[R_p - R_f]
    std_excess = excess.std()                 # œÉ(R_p - R_f)
    sharpe = np.sqrt(periodos_a√±o) * promedio_excess / std_excess


    # Sortino Ratio: retorno excedente por unidad de riesgo negativo. Enfocado en p√©rdidas.
    downside = r[r < target] - target         # solo p√©rdidas respecto al objetivo
    downside_std = np.sqrt(np.mean(downside**2))
    sortino = np.sqrt(periodos_a√±o) * promedio_excess / downside_std


    # M√°ximo drawdown: ca√≠da porcentual m√°s grande de pico a valle
    curva = (1 + r).cumprod()                 # rendimeinto compuesto
    # dividido entre el valor maximo hasta ese momento. Me quedo con el minimo porque entre mas negativo mas grande la caida
    max_dd = (curva / curva.cummax() - 1).min()


    # Beta, cov, corr
    cov = np.cov(excess, excess_benchmark)[0, 1]
    beta = cov / excess_benchmark.var()
    corr = np.corrcoef(r, excess_benchmark)[0, 1]


    # Treynor Ratio: retorno excedente por unidad de riesgo sistem√°tico.
    treynor = np.mean(excess) * periodos_a√±o / beta


    # Information Ratio (IR): eficiencia del gestor activo al generar alpha por unidad de riesgo relativo.
    active = r - benchmark           # diferencia activa (alpha)
    ir = np.sqrt(periodos_a√±o) * np.mean(active) / np.std(active)  # media / volatilidad del tracking error


    #  Calmar Ratio: mide la rentabilidad ajustada por la peor p√©rdida sufrida.
    cumulative = (1 + r).cumprod()           # curva de capital
    max_dd_ = abs(max_dd)             # m√°xima ca√≠da (m√°x. drawdown)
    cagr = (cumulative[-1])**(periodos_a√±o / len(r)) - 1  # tasa compuesta anual (CAGR)
    calmar = cagr / max_dd


    # Guardar todo
    metricas = {
        "ret_anual": ret_prom,
        "vol_anual": volatilidad,
        "correlacion": corr,
        "cov": cov,
        "sesgo": sesgo,
        "curtosis": curtosis,
        "VaR_95": var_95,
        "CVaR_95": cvar_95,
        "sharpe": sharpe,
        "sortino": sortino,
        "max_drawdown": max_dd,
        "beta": beta,
        "treynor": treynor,
        "information_ratio": ir,
        "calmar": calmar
    }

    return metricas

# ==============================
# PASO 3: GENERACION DE PORTAFOLIOS
# ==============================

cov_matrix_regions = returns_regions.cov() * 252
cov_matrix_sectors = returns_sectors.cov() * 252

#garantizar que cumpla con el 100% invertido
def constraint_sum_weights():
    return {'type':'eq', 'fun':lambda w: np.sum(w) - 1}


# ==============================
# Portafolio m√≠nima varianza
# ==============================
def minimize_volatility(returns, benchmark, rf_diaria, periodos_a√±o=252):
    # Numero de activos, regiones o sectores
    n_assets = returns.shape[1]

    bounds = tuple((0,1) for _ in range(n_assets))           # NO short selling. Establece los minimos y maximos de cada peso
    x0 = np.ones(n_assets) / n_assets                        # Pesos iniciales iguales

    # Optimizaci√≥n: minimizar volatilidad
    result = op.minimize(
        lambda w: metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_a√±o)["vol_anual"],  # minimize volatility
        x0,
        method='SLSQP',
        constraints=constraint_sum_weights(),
        bounds=bounds
    )

    metricas_opt = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_a√±o)

    return result.x, metricas_opt



# ==============================
# Portafolio m√°ximo retorno
# ==============================
def maximize_return(returns, benchmark, rf_diaria, periodos_a√±o=252):
    # N√∫mero de activos
    n_assets = returns.shape[1]

    # Pesos iniciales y l√≠mites
    bounds = tuple((0, 1) for _ in range(n_assets))  # no short selling
    x0 = np.ones(n_assets) / n_assets                # pesos iniciales iguales

    # Retorno inicial
    # These lines are not strictly necessary for the optimization but can remain for debugging or initial values.
    retornos_initial = metricas_portafolio(returns, x0, benchmark, rf_diaria, periodos_a√±o)["ret_anual"]
    volatilidad_initial = metricas_portafolio(returns, x0, benchmark, rf_diaria, periodos_a√±o)["vol_anual"]

    # Optimizaci√≥n: maximizar retorno anual
    result = op.minimize(
        lambda w: -metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_a√±o)["ret_anual"],
        x0,
        method='SLSQP',
        constraints=constraint_sum_weights(),
        bounds=bounds
    )

    metricas_opt = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_a√±o)

    return result.x, metricas_opt



# ==============================
# Portafolio m√°ximo Sharpe
# ==============================
def maximize_sharpe(returns, benchmark, rf_diaria, periodos_a√±o=252):
  # N√∫mero de activos
  n_assets = returns.shape[1]

  # Pesos iniciales y l√≠mites
  bounds = tuple((0, 1) for _ in range(n_assets))  # no short selling
  x0 = np.ones(n_assets) / n_assets                # pesos iniciales iguales

  # Optimizaci√≥n
  result = op.minimize(
      lambda w: -metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_a√±o)["sharpe"], # Pass a callable function
      x0,
      method='SLSQP',
      constraints=constraint_sum_weights(),
      bounds=bounds
  )

  metricas_opt = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_a√±o)

  return result.x, metricas_opt

# ==============================
# Frontera eficiente
# ==============================

def efficient_frontier(returns, benchmark, rf_diaria, periodos_a√±o=252, n_points=50):
    n_assets = returns.shape[1]
    x0 = np.ones(n_assets) / n_assets
    bounds = tuple((0, 1) for _ in range(n_assets))

    # Retornos promedio anualizados por activo
    mean_returns = returns.mean() * periodos_a√±o

    frontier_vols = []
    frontier_rets = []

    for tr in np.linspace(mean_returns.min(), mean_returns.max(), n_points):
        # Restricciones: suma de pesos = 1 y retorno = tr
        constraints = [
            constraint_sum_weights(),
            {'type': 'eq', 'fun': lambda w, tr=tr: np.dot(w, mean_returns) - tr}
        ]

        # Minimizar volatilidad para un retorno objetivo
        result = op.minimize(
            lambda w: metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_a√±o)["vol_anual"],
            x0,
            method='SLSQP',
            bounds=bounds,
            constraints=constraints
        )

        if result.success:
            metrics = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_a√±o)
            frontier_vols.append(metrics["vol_anual"])
            frontier_rets.append(tr)

    return np.array(frontier_vols), np.array(frontier_rets)

# ==============================
# Ejecutar optimizaciones
# ==============================
w_min, metrics_min = minimize_volatility(returns_regions, benchmark_regions, rf_diaria)
w_mx, metrics_mx = maximize_return(returns_regions, benchmark_regions, rf_diaria)
w_sharpe, metrics_sharpe = maximize_sharpe(returns_regions, benchmark_regions, rf_diaria)

# Extraer retorno y volatilidad
ret_min = metrics_min["ret_anual"]
vol_min = metrics_min["vol_anual"]

ret_mx = metrics_mx["ret_anual"]
vol_mx = metrics_mx["vol_anual"]

ret_s = metrics_sharpe["ret_anual"]
vol_s = metrics_sharpe["vol_anual"]


# ==============================
# 8. Frontera eficiente
# ==============================
front_vols, front_rets = efficient_frontier(returns_regions, benchmark_regions, rf_diaria)

# ==============================
# 9. Gr√°fico profesional
# ==============================
plt.figure(figsize=(10,6))

# Frontera eficiente
plt.plot(front_vols, front_rets, color='blue', linewidth=2, label="Frontera eficiente")

# Portafolio m√≠nimo riesgo
plt.scatter(vol_min, ret_min, color='red', s=80, label="Min Var")

# Portafolio m√°ximo Sharpe
plt.scatter(vol_s, ret_s, color='green', s=80, label="M√°ximo Sharpe")

# Portafolio m√°ximo retorno
plt.scatter(vol_mx, ret_mx, color='purple', s=80, label="M√°ximo retorno")

plt.title("Frontera Eficiente - Modelo de Markowitz")
plt.xlabel("Volatilidad")
plt.ylabel("Retorno esperado")
plt.legend()
plt.grid(True)
plt.show()

# ---------------------------
# PASO 4: PORTAFOLIO DEL USUARIO
# ---------------------------


def evaluar_portafolio_usuario():
    """
    Permite al usuario ingresar los pesos de su portafolio para sectores y regiones,
    valida los inputs y calcula las m√©tricas usando metricas_portafolio.
    """
    import numpy as np

    # ---------------------------
    # Instrucciones al usuario
    # ---------------------------
    print("==== Evaluador de Portafolio ====")
    print(f"Debe ingresar {len(universo['sectors']['tickers'])} pesos para SECTORES separados por coma.")
    print(f"Debe ingresar {len(universo['regions']['tickers'])} pesos para REGIONES separados por coma.")
    print("Los pesos deben estar entre 0 y 1 y la suma debe ser 1 para cada portafolio.\n")

    # ---------------------------
    # Input del usuario: sectores
    # ---------------------------
    while True:
        try:
            input_sectores = input("Ingrese los pesos para SECTORES: ")
            w_sectores = np.array([float(x) for x in input_sectores.split(",")])
            if len(w_sectores) != len(universo['sectors']['tickers']):
                raise ValueError("Cantidad de pesos incorrecta.")
            if not np.isclose(np.sum(w_sectores), 1):
                print("‚ö†Ô∏è  La suma de los pesos no es 1. Se normalizar√°n autom√°ticamente.")
                w_sectores = w_sectores / np.sum(w_sectores)
            break
        except Exception as e:
            print("Error:", e, "Intente de nuevo.")

    # ---------------------------
    # Input del usuario: regiones
    # ---------------------------
    while True:
        try:
            input_regiones = input("Ingrese los pesos para REGIONES: ")
            w_regiones = np.array([float(x) for x in input_regiones.split(",")])
            if len(w_regiones) != len(universo['regions']['tickers']):
                raise ValueError("Cantidad de pesos incorrecta.")
            if not np.isclose(np.sum(w_regiones), 1):
                print("‚ö†Ô∏è  La suma de los pesos no es 1. Se normalizar√°n autom√°ticamente.")
                w_regiones = w_regiones / np.sum(w_regiones)
            break
        except Exception as e:
            print("Error:", e, "Intente de nuevo.")

    # ---------------------------
    # Calcular m√©tricas
    # ---------------------------
    metrics_sectores = metricas_portafolio(returns_sectors, w_sectores, benchmark_sectors, rf_diaria, periodos_a√±o)
    metrics_regiones = metricas_portafolio(returns_regions, w_regiones, benchmark_regions, rf_diaria, periodos_a√±o)

    # ---------------------------
    # Mostrar resultados
    # ---------------------------
    print("\n==== M√©tricas del Portafolio de SECTORES ====")
    for k, v in metrics_sectores.items():
        print(f"{k}: {v:.4f}")

    print("\n==== M√©tricas del Portafolio de REGIONES ====")
    for k, v in metrics_regiones.items():
        print(f"{k}: {v:.4f}")

evaluar_portafolio_usuario()

"""PASO 5: VISUALIZACION"""

import streamlit as st
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

st.set_page_config(page_title="Optimizaci√≥n de Portafolio", layout="wide")

# -------------------------------
# T√≠tulo y descripci√≥n
# -------------------------------
st.title("üìà Optimizaci√≥n de Portafolio")

st.markdown("""
Esta app permite comparar portafolios de **regiones** y **sectores**, calculando m√©tricas clave:

- **Volatilidad:** mejor entre menor.
- **Retorno anualizado:** mejor entre mayor.
- **Sharpe ratio:** retorno ajustado al riesgo, mejor entre mayor.
- **M√°ximo drawdown:** menor valor indica menos riesgo de p√©rdida extrema.
- **Sortino ratio:** similar a Sharpe, considerando solo las ca√≠das.

Selecciona el portafolio y criterio que te interesa y la app mostrar√° recomendaciones.
""")

# -------------------------------
# Selecci√≥n de portafolio y m√©trica
# -------------------------------
st.header("1Ô∏è‚É£ Comparativa Portafolios")

universos = ["Regiones", "Sectores"]
universo_sel = st.radio("Elige universo:", universos)

criterios = ["M√°ximo Sharpe", "M√≠nima Volatilidad", "M√°ximo Retorno"]
criterio_sel = st.radio("Prioridad al escoger portafolio:", criterios)

# -------------------------------
# Datos seg√∫n selecci√≥n
# -------------------------------
if universo_sel == "Regiones":
    returns = returns_regions
    benchmark = benchmark_regions
else:
    returns = returns_sectors
    benchmark = benchmark_sectors

# Calculamos portafolios √≥ptimos
w_min, m_min = minimize_volatility(returns, benchmark, rf_diaria)
w_maxr, m_maxr = maximize_return(returns, benchmark, rf_diaria)
w_sharpe, m_sharpe = maximize_sharpe(returns, benchmark, rf_diaria)

# Crear arrays de m√©tricas para graficar
rets = [m_min["ret_anual"], m_maxr["ret_anual"], m_sharpe["ret_anual"]]
vols = [m_min["vol_anual"], m_maxr["vol_anual"], m_sharpe["vol_anual"]]
labels = ["Min Vol", "Max Retorno", "Max Sharpe"]

# -------------------------------
# Gr√°fica retorno vs volatilidad
# -------------------------------
fig, ax = plt.subplots(figsize=(8,6))
ax.scatter(vols, rets, color=['red','purple','green'], s=100)
for i, txt in enumerate(labels):
    ax.annotate(txt, (vols[i], rets[i]), xytext=(5,5), textcoords='offset points')
ax.set_xlabel("Volatilidad Anualizada")
ax.set_ylabel("Retorno Anualizado")
ax.set_title(f"Portafolios √ìptimos - {universo_sel}")
ax.grid(True)
st.pyplot(fig)

# -------------------------------
# Mostrar pesos del mejor portafolio seg√∫n prioridad
# -------------------------------
st.header("2Ô∏è‚É£ Mejor Portafolio seg√∫n tu prioridad")
if criterio_sel == "M√°ximo Sharpe":
    best_metrics = m_sharpe
    best_weights = w_sharpe
elif criterio_sel == "M√≠nima Volatilidad":
    best_metrics = m_min
    best_weights = w_min
else:
    best_metrics = m_maxr
    best_weights = w_maxr

st.subheader(f"Portafolio recomendado: {criterio_sel}")
st.table(pd.DataFrame(best_metrics, index=[0]).T)

st.subheader("Pesos √≥ptimos por activo")
st.bar_chart(pd.Series(best_weights, index=returns.columns))

# -------------------------------
# 3Ô∏è‚É£ Espacio interactivo: ingresar tus propios pesos
# -------------------------------
st.header("3Ô∏è‚É£ Ingrese su propio portafolio")
user_weights = []
st.markdown("Ingrese pesos para cada activo separados por coma, sumando 1 (si no suman 1 se normalizar√°n autom√°ticamente):")
default_weights = np.ones(returns.shape[1])/returns.shape[1]
user_input = st.text_input("Pesos:", ",".join([str(round(x,2)) for x in default_weights]))

if st.button("Calcular m√©tricas de su portafolio"):
    try:
        w_user = np.array([float(x.strip()) for x in user_input.split(",")])
        if len(w_user) != returns.shape[1]:
            st.error(f"Debes ingresar {returns.shape[1]} pesos.")
        else:
            # Normalizar
            if not np.isclose(np.sum(w_user),1):
                w_user = w_user/np.sum(w_user)

            user_metrics = metricas_portafolio(returns, w_user, benchmark, rf_diaria)
            st.subheader("M√©tricas de tu portafolio")
            st.table(pd.DataFrame(user_metrics,index=[0]).T)

            st.subheader("Pesos de tu portafolio")
            st.bar_chart(pd.Series(w_user, index=returns.columns))
    except Exception as e:
        st.error(f"Error al procesar los pesos: {e}")