# -*- coding: utf-8 -*-
"""Seminario.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rWZmnEFsUPuwGRk3Z3wMrGw39iC4xwXS
"""

import numpy as np
import pandas as pd
import yfinance as yf
import cvxpy as cp
from scipy.stats import skew, kurtosis, norm
import scipy.optimize as op
from tqdm import tqdm
import matplotlib.pyplot as plt
import datetime
import warnings
from typing import List, Tuple, Dict, Optional
import streamlit as st

# Desactivar warnings
warnings.filterwarnings("ignore")

# ---------------------------
# PASO 1: RECOLECCI√ìN DE DATOS
# ---------------------------

# ---------------------------
# Universo
# ---------------------------
universo = {
    "regions": {
        "tickers": ["SPLG", "EWC", "IEUR", "EEM", "EWJ"],
        "weights": np.array([0.7062, 0.0323, 0.1176, 0.0902, 0.0537])
    },
    "sectors": {
        "tickers": ["XLC","XLY","XLP","XLE","XLF","XLV","XLI","XLB","XLRE","XLK","XLU"],
        "weights": np.array([0.0999,0.1025,0.0482,0.0295,0.1307,0.0958,0.0809,0.0166,0.0187,0.3535,0.0237])
    }
}


# ---------------------------
# Descargar datos
# ---------------------------

@st.cache_data
def cargar_datos():
    data_regions = yf.download(universo["regions"]["tickers"],
                               start="2019-01-01",
                               end=datetime.date.today().isoformat())["Close"]

    data_sectors = yf.download(universo["sectors"]["tickers"],
                               start="2019-01-01",
                               end=datetime.date.today().isoformat())["Close"]

    return data_regions, data_sectors

data_regions, data_sectors = cargar_datos()

# Retornos
returns_regions = data_regions.pct_change().dropna()
returns_sectors = data_sectors.pct_change().dropna()


# ---------------------------
# Par√°metros
# ---------------------------
rf = 0.109
periodos_a√±o = 252

rf_diaria = (1 + rf)**(1/periodos_a√±o) - 1

# ---------------------------
# Benchmark
# ---------------------------
benchmark_regions = returns_regions.dot(universo["regions"]["weights"])
benchmark_sectors = returns_sectors.dot(universo["sectors"]["weights"])

# ------------------------
# PASO 2
# ------------------------


def metricas_portafolio(returns: pd.DataFrame,
                        weights: np.ndarray,
                        benchmark: pd.Series,
                        rf_diaria: float,
                        periodos_a√±o: int = 252,
                        target: float = 0.0
                        ) -> dict:
    """
    Calcula las m√©tricas de un portafolio dadas sus series de rendimientos por activo
    y sus pesos.
    """

    # ------------------------
    # 1. Retorno del portafolio
    # ------------------------
    # suma ponderada de rendimientos diarios
    r = returns.dot(weights)

    excess = r - rf_diaria
    excess_benchmark = benchmark - rf_diaria

    metricas = {}

    # ------------------------
    # M√©tricas
    # ------------------------

    # Retorno promedio anualizado
    ret_prom = r.mean() * periodos_a√±o

    # Volatilidad: desviaci√≥n est√°ndar anualizada
    volatilidad = r.std() * np.sqrt(periodos_a√±o)

    # Sesgo: que tan simetrico es. Negativo = cola izquierda = perdidas fuertes
    sesgo = r.skew()

    # Curtosis: que tan pesadas son las colas. Alta = eventos extremos frecuentes
    curtosis = r.kurtosis()

    # VaR 95%
    var_95 = r.quantile(0.05)

    # CVaR 95%
    cvar_95 = r[r <= var_95].mean()


    # Sharpe ratio: rendimiento ajustado al riesgo
    # retornos en exceso = R_p - R_f
    promedio_excess = excess.mean()           # E[R_p - R_f]
    std_excess = excess.std()                 # œÉ(R_p - R_f)
    sharpe = np.sqrt(periodos_a√±o) * promedio_excess / std_excess


    # Sortino Ratio: retorno excedente por unidad de riesgo negativo. Enfocado en p√©rdidas.
    downside = r[r < target] - target         # solo p√©rdidas respecto al objetivo
    downside_std = np.sqrt(np.mean(downside**2))
    sortino = np.sqrt(periodos_a√±o) * promedio_excess / downside_std


    # M√°ximo drawdown: ca√≠da porcentual m√°s grande de pico a valle
    curva = (1 + r).cumprod()                 # rendimeinto compuesto
    # dividido entre el valor maximo hasta ese momento. Me quedo con el minimo porque entre mas negativo mas grande la caida
    max_dd = (curva / curva.cummax() - 1).min()


    # Beta, cov, corr
    cov = np.cov(excess, excess_benchmark)[0, 1]
    beta = cov / excess_benchmark.var()
    corr = np.corrcoef(r, excess_benchmark)[0, 1]


    # Treynor Ratio: retorno excedente por unidad de riesgo sistem√°tico.
    treynor = np.mean(excess) * periodos_a√±o / beta


    # Information Ratio (IR): eficiencia del gestor activo al generar alpha por unidad de riesgo relativo.
    active = r - benchmark           # diferencia activa (alpha)
    ir = np.sqrt(periodos_a√±o) * np.mean(active) / np.std(active)  # media / volatilidad del tracking error


    #  Calmar Ratio: mide la rentabilidad ajustada por la peor p√©rdida sufrida.
    cumulative = (1 + r).cumprod()           # curva de capital
    max_dd_ = abs(max_dd)             # m√°xima ca√≠da (m√°x. drawdown)
    cagr = (cumulative[-1])**(periodos_a√±o / len(r)) - 1  # tasa compuesta anual (CAGR)
    calmar = cagr / max_dd


    # Guardar todo
    metricas = {
        "ret_anual": ret_prom,
        "vol_anual": volatilidad,
        "correlacion": corr,
        "cov": cov,
        "sesgo": sesgo,
        "curtosis": curtosis,
        "VaR_95": var_95,
        "CVaR_95": cvar_95,
        "sharpe": sharpe,
        "sortino": sortino,
        "max_drawdown": max_dd,
        "beta": beta,
        "treynor": treynor,
        "information_ratio": ir,
        "calmar": calmar
    }

    return metricas

# ==============================
# PASO 3: GENERACION DE PORTAFOLIOS
# ==============================

cov_matrix_regions = returns_regions.cov() * 252
cov_matrix_sectors = returns_sectors.cov() * 252

#garantizar que cumpla con el 100% invertido
def constraint_sum_weights():
    return {'type':'eq', 'fun':lambda w: np.sum(w) - 1}


# ==============================
# Portafolio m√≠nima varianza
# ==============================
def minimize_volatility(returns, benchmark, rf_diaria, periodos_a√±o=252):
    # Numero de activos, regiones o sectores
    n_assets = returns.shape[1]

    bounds = tuple((0,1) for _ in range(n_assets))           # NO short selling. Establece los minimos y maximos de cada peso
    x0 = np.ones(n_assets) / n_assets                        # Pesos iniciales iguales

    # Optimizaci√≥n: minimizar volatilidad
    result = op.minimize(
        lambda w: metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_a√±o)["vol_anual"],  # minimize volatility
        x0,
        method='SLSQP',
        constraints=constraint_sum_weights(),
        bounds=bounds
    )

    metricas_opt = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_a√±o)

    return result.x, metricas_opt



# ==============================
# Portafolio m√°ximo retorno
# ==============================
def maximize_return(returns, benchmark, rf_diaria, periodos_a√±o=252):
    # N√∫mero de activos
    n_assets = returns.shape[1]

    # Pesos iniciales y l√≠mites
    bounds = tuple((0, 1) for _ in range(n_assets))  # no short selling
    x0 = np.ones(n_assets) / n_assets                # pesos iniciales iguales

    # Retorno inicial
    # These lines are not strictly necessary for the optimization but can remain for debugging or initial values.
    retornos_initial = metricas_portafolio(returns, x0, benchmark, rf_diaria, periodos_a√±o)["ret_anual"]
    volatilidad_initial = metricas_portafolio(returns, x0, benchmark, rf_diaria, periodos_a√±o)["vol_anual"]

    # Optimizaci√≥n: maximizar retorno anual
    result = op.minimize(
        lambda w: -metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_a√±o)["ret_anual"],
        x0,
        method='SLSQP',
        constraints=constraint_sum_weights(),
        bounds=bounds
    )

    metricas_opt = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_a√±o)

    return result.x, metricas_opt



# ==============================
# Portafolio m√°ximo Sharpe
# ==============================
def maximize_sharpe(returns, benchmark, rf_diaria, periodos_a√±o=252):
  # N√∫mero de activos
  n_assets = returns.shape[1]

  # Pesos iniciales y l√≠mites
  bounds = tuple((0, 1) for _ in range(n_assets))  # no short selling
  x0 = np.ones(n_assets) / n_assets                # pesos iniciales iguales

  # Optimizaci√≥n
  result = op.minimize(
      lambda w: -metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_a√±o)["sharpe"], # Pass a callable function
      x0,
      method='SLSQP',
      constraints=constraint_sum_weights(),
      bounds=bounds
  )

  metricas_opt = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_a√±o)

  return result.x, metricas_opt

"""# ==============================
# Frontera eficiente
# ==============================

def efficient_frontier(returns, benchmark, rf_diaria, periodos_a√±o=252, n_points=50):
    n_assets = returns.shape[1]
    x0 = np.ones(n_assets) / n_assets
    bounds = tuple((0, 1) for _ in range(n_assets))

    # Retornos promedio anualizados por activo
    mean_returns = returns.mean() * periodos_a√±o

    frontier_vols = []
    frontier_rets = []

    for tr in np.linspace(mean_returns.min(), mean_returns.max(), n_points):
        # Restricciones: suma de pesos = 1 y retorno = tr
        constraints = [
            constraint_sum_weights(),
            {'type': 'eq', 'fun': lambda w, tr=tr: np.dot(w, mean_returns) - tr}
        ]

        # Minimizar volatilidad para un retorno objetivo
        result = op.minimize(
            lambda w: metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_a√±o)["vol_anual"],
            x0,
            method='SLSQP',
            bounds=bounds,
            constraints=constraints
        )

        if result.success:
            metrics = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_a√±o)
            frontier_vols.append(metrics["vol_anual"])
            frontier_rets.append(tr)

    return np.array(frontier_vols), np.array(frontier_rets)

# ==============================
# Ejecutar optimizaciones
# ==============================
w_min, metrics_min = minimize_volatility(returns_regions, benchmark_regions, rf_diaria)
w_mx, metrics_mx = maximize_return(returns_regions, benchmark_regions, rf_diaria)
w_sharpe, metrics_sharpe = maximize_sharpe(returns_regions, benchmark_regions, rf_diaria)

# Extraer retorno y volatilidad
ret_min = metrics_min["ret_anual"]
vol_min = metrics_min["vol_anual"]

ret_mx = metrics_mx["ret_anual"]
vol_mx = metrics_mx["vol_anual"]

ret_s = metrics_sharpe["ret_anual"]
vol_s = metrics_sharpe["vol_anual"]


# ==============================
# 8. Frontera eficiente
# ==============================
front_vols, front_rets = efficient_frontier(returns_regions, benchmark_regions, rf_diaria, periodos_a√±o=252, n_points=50)

# ==============================
# 9. Gr√°fico profesional
# ==============================
plt.figure(figsize=(10,6))

# Frontera eficiente
plt.plot(front_vols, front_rets, color='blue', linewidth=2, label="Frontera eficiente", alpha=.8)

# Portafolio m√≠nimo riesgo
plt.scatter(vol_min, ret_min, color='red', s=80, label="Min Var", alpha=.8)

# Portafolio m√°ximo Sharpe
plt.scatter(vol_s, ret_s, color='green', s=80, label="M√°ximo Sharpe")

# Portafolio m√°ximo retorno
plt.scatter(vol_mx, ret_mx, color='purple', s=80, label="M√°ximo retorno")

plt.title("Frontera Eficiente - Modelo de Markowitz")
plt.xlabel("Volatilidad")
plt.ylabel("Retorno esperado")
plt.legend()
plt.grid(True)
plt.show()
"""

# ---------------------------
# PASO 4: PORTAFOLIO DEL USUARIO
# ---------------------------


def evaluar_portafolio_usuario():
    """
    Permite al usuario ingresar los pesos de su portafolio para sectores y regiones,
    valida los inputs y calcula las m√©tricas usando metricas_portafolio.
    """
    import numpy as np

    # ---------------------------
    # Instrucciones al usuario
    # ---------------------------
    print("==== Evaluador de Portafolio ====")
    print(f"Debe ingresar {len(universo['sectors']['tickers'])} pesos para SECTORES separados por coma.")
    print(f"Debe ingresar {len(universo['regions']['tickers'])} pesos para REGIONES separados por coma.")
    print("Los pesos deben estar entre 0 y 1 y la suma debe ser 1 para cada portafolio.\n")

    # ---------------------------
    # Input del usuario: sectores
    # ---------------------------
    while True:
        try:
            input_sectores = input("Ingrese los pesos para SECTORES: ")
            w_sectores = np.array([float(x) for x in input_sectores.split(",")])
            if len(w_sectores) != len(universo['sectors']['tickers']):
                raise ValueError("Cantidad de pesos incorrecta.")
            if not np.isclose(np.sum(w_sectores), 1):
                print("‚ö†Ô∏è  La suma de los pesos no es 1. Se normalizar√°n autom√°ticamente.")
                w_sectores = w_sectores / np.sum(w_sectores)
            break
        except Exception as e:
            print("Error:", e, "Intente de nuevo.")

    # ---------------------------
    # Input del usuario: regiones
    # ---------------------------
    while True:
        try:
            input_regiones = input("Ingrese los pesos para REGIONES: ")
            w_regiones = np.array([float(x) for x in input_regiones.split(",")])
            if len(w_regiones) != len(universo['regions']['tickers']):
                raise ValueError("Cantidad de pesos incorrecta.")
            if not np.isclose(np.sum(w_regiones), 1):
                print("‚ö†Ô∏è  La suma de los pesos no es 1. Se normalizar√°n autom√°ticamente.")
                w_regiones = w_regiones / np.sum(w_regiones)
            break
        except Exception as e:
            print("Error:", e, "Intente de nuevo.")

    # ---------------------------
    # Calcular m√©tricas
    # ---------------------------
    metrics_sectores = metricas_portafolio(returns_sectors, w_sectores, benchmark_sectors, rf_diaria, periodos_a√±o)
    metrics_regiones = metricas_portafolio(returns_regions, w_regiones, benchmark_regions, rf_diaria, periodos_a√±o)

    # ---------------------------
    # Mostrar resultados
    # ---------------------------
    print("\n==== M√©tricas del Portafolio de SECTORES ====")
    for k, v in metrics_sectores.items():
        print(f"{k}: {v:.4f}")

    print("\n==== M√©tricas del Portafolio de REGIONES ====")
    for k, v in metrics_regiones.items():
        print(f"{k}: {v:.4f}")

# ============================================
# ===============   STREAMLIT UI   ===========
# ============================================

import streamlit as st
import plotly.express as px

def run_app():

    st.title("Optimizaci√≥n de Portafolio")

    st.markdown("""
    Esta app compara portafolios de **regiones** y **sectores**, calculando m√©tricas clave:

    - **Volatilidad:** mejor entre menor.
    - **Retorno anualizado:** mejor entre mayor.
    - **Sharpe ratio:** retorno ajustado al riesgo, mejor entre mayor.
    - **M√°ximo drawdown:** menor p√©rdida m√°xima.
    - **Sortino ratio:** versi√≥n de Sharpe basada solo en ca√≠das.

    Selecciona una m√©trica y los portafolios a comparar.
    """)

    # ======== Selecci√≥n del usuario ========
    metric = st.selectbox(
        "Selecciona la m√©trica a graficar:",
        ["retorno", "vol", "sharpe", "sortino", "mdd"]
    )

    port_names = list(portafolios.keys())
    selected = st.multiselect(
        "Selecciona los portafolios a comparar:",
        port_names,
        default=port_names
    )

    # ======== Gr√°fica ========
    valores = {p: metrics[p][metric] for p in selected}
    fig = px.bar(
        x=list(valores.keys()),
        y=list(valores.values()),
        labels={'x': 'Portafolio', 'y': metric},
        title=f"Comparaci√≥n por m√©trica: {metric}"
    )
    st.plotly_chart(fig)

    # ======== Mejor portafolio ========
    if metric in ["retorno", "sharpe", "sortino"]:
        best = max(valores, key=valores.get)
    else:
        best = min(valores, key=valores.get)

    st.success(f"üìå El mejor portafolio seg√∫n **{metric}** es: **{best}**")

    # ======== Evaluaci√≥n del portafolio elegido por el usuario ========
    st.subheader("Evaluaci√≥n de tu propio portafolio")

    user_weights = st.text_input(
        "Ingresa tus pesos separados por coma (por ejemplo: 0.2,0.3,0.5):"
    )

    if user_weights:
        try:
            w = np.array([float(x) for x in user_weights.split(",")])
            w /= np.sum(w)

            m = metricas_portafolio(returns, w, benchmark, rf_diaria)

            st.write("### M√©tricas de tu portafolio")
            st.json(m)

            # Gr√°tica de barras
            fig2 = px.bar(
                x=list(m.keys()),
                y=list(m.values()),
                title="M√©tricas de tu portafolio"
            )
            st.plotly_chart(fig2)

            # Comentario autom√°tico
            comment = []
            if m["sharpe"] > np.mean([metrics[p]["sharpe"] for p in port_names]):
                comment.append("‚úîÔ∏è Buen Sharpe ratio.")
            else:
                comment.append("‚ö†Ô∏è Sharpe ratio por debajo del promedio.")

            if m["vol"] < np.mean([metrics[p]["vol"] for p in port_names]):
                comment.append("‚úîÔ∏è Baja volatilidad.")
            else:
                comment.append("‚ö†Ô∏è Alta volatilidad comparada con otros portafolios.")

            st.info("\n".join(comment))

        except:
            st.error("Error al interpretar los pesos. Revisa el formato.")

if __name__ == "__main__":
    run_app()