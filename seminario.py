# -*- coding: utf-8 -*-
"""Seminario.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rWZmnEFsUPuwGRk3Z3wMrGw39iC4xwXS
"""

import numpy as np
import pandas as pd
import yfinance as yf
import cvxpy as cp
from scipy.stats import skew, kurtosis, norm
import scipy.optimize as op
from tqdm import tqdm
import matplotlib.pyplot as plt
import datetime
import warnings
from typing import List, Tuple, Dict, Optional
import streamlit as st

# Desactivar warnings
warnings.filterwarnings("ignore")

# ---------------------------
# PASO 1: RECOLECCIÓN DE DATOS
# ---------------------------

# ---------------------------
# Universo
# ---------------------------
universo = {
    "regions": {
        "tickers": ["SPLG", "EWC", "IEUR", "EEM", "EWJ"],
        "weights": np.array([0.7062, 0.0323, 0.1176, 0.0902, 0.0537])
    },
    "sectors": {
        "tickers": ["XLC","XLY","XLP","XLE","XLF","XLV","XLI","XLB","XLRE","XLK","XLU"],
        "weights": np.array([0.0999,0.1025,0.0482,0.0295,0.1307,0.0958,0.0809,0.0166,0.0187,0.3535,0.0237])
    }
}


# ---------------------------
# Descargar datos
# ---------------------------
data_regions = yf.download(universo["regions"]["tickers"], start="2019-01-01", end=datetime.date.today().isoformat())["Close"]
data_sectors = yf.download(universo["sectors"]["tickers"], start="2019-01-01", end=datetime.date.today().isoformat())["Close"]

# Retornos
returns_regions = data_regions.pct_change().dropna()
returns_sectors = data_sectors.pct_change().dropna()


# ---------------------------
# Parámetros
# ---------------------------
rf = 0.109
periodos_año = 252

rf_diaria = (1 + rf)**(1/periodos_año) - 1

# ---------------------------
# Benchmark
# ---------------------------
benchmark_regions = returns_regions.dot(universo["regions"]["weights"])
benchmark_sectors = returns_sectors.dot(universo["sectors"]["weights"])

# ------------------------
# PASO 2
# ------------------------


def metricas_portafolio(returns: pd.DataFrame,
                        weights: np.ndarray,
                        benchmark: pd.Series,
                        rf_diaria: float,
                        periodos_año: int = 252,
                        target: float = 0.0
                        ) -> dict:
    """
    Calcula las métricas de un portafolio dadas sus series de rendimientos por activo
    y sus pesos.
    """

    # ------------------------
    # 1. Retorno del portafolio
    # ------------------------
    # suma ponderada de rendimientos diarios
    r = returns.dot(weights)

    excess = r - rf_diaria
    excess_benchmark = benchmark - rf_diaria

    metricas = {}

    # ------------------------
    # Métricas
    # ------------------------

    # Retorno promedio anualizado
    ret_prom = r.mean() * periodos_año

    # Volatilidad: desviación estándar anualizada
    volatilidad = r.std() * np.sqrt(periodos_año)

    # Sesgo: que tan simetrico es. Negativo = cola izquierda = perdidas fuertes
    sesgo = r.skew()

    # Curtosis: que tan pesadas son las colas. Alta = eventos extremos frecuentes
    curtosis = r.kurtosis()

    # VaR 95%
    var_95 = r.quantile(0.05)

    # CVaR 95%
    cvar_95 = r[r <= var_95].mean()


    # Sharpe ratio: rendimiento ajustado al riesgo
    # retornos en exceso = R_p - R_f
    promedio_excess = excess.mean()           # E[R_p - R_f]
    std_excess = excess.std()                 # σ(R_p - R_f)
    sharpe = np.sqrt(periodos_año) * promedio_excess / std_excess


    # Sortino Ratio: retorno excedente por unidad de riesgo negativo. Enfocado en pérdidas.
    downside = r[r < target] - target         # solo pérdidas respecto al objetivo
    downside_std = np.sqrt(np.mean(downside**2))
    sortino = np.sqrt(periodos_año) * promedio_excess / downside_std


    # Máximo drawdown: caída porcentual más grande de pico a valle
    curva = (1 + r).cumprod()                 # rendimeinto compuesto
    # dividido entre el valor maximo hasta ese momento. Me quedo con el minimo porque entre mas negativo mas grande la caida
    max_dd = (curva / curva.cummax() - 1).min()


    # Beta, cov, corr
    cov = np.cov(excess, excess_benchmark)[0, 1]
    beta = cov / excess_benchmark.var()
    corr = np.corrcoef(r, excess_benchmark)[0, 1]


    # Treynor Ratio: retorno excedente por unidad de riesgo sistemático.
    treynor = np.mean(excess) * periodos_año / beta


    # Information Ratio (IR): eficiencia del gestor activo al generar alpha por unidad de riesgo relativo.
    active = r - benchmark           # diferencia activa (alpha)
    ir = np.sqrt(periodos_año) * np.mean(active) / np.std(active)  # media / volatilidad del tracking error


    #  Calmar Ratio: mide la rentabilidad ajustada por la peor pérdida sufrida.
    cumulative = (1 + r).cumprod()           # curva de capital
    max_dd_ = abs(max_dd)             # máxima caída (máx. drawdown)
    cagr = (cumulative[-1])**(periodos_año / len(r)) - 1  # tasa compuesta anual (CAGR)
    calmar = cagr / max_dd


    # Guardar todo
    metricas = {
        "ret_anual": ret_prom,
        "vol_anual": volatilidad,
        "correlacion": corr,
        "cov": cov,
        "sesgo": sesgo,
        "curtosis": curtosis,
        "VaR_95": var_95,
        "CVaR_95": cvar_95,
        "sharpe": sharpe,
        "sortino": sortino,
        "max_drawdown": max_dd,
        "beta": beta,
        "treynor": treynor,
        "information_ratio": ir,
        "calmar": calmar
    }

    return metricas

# ==============================
# PASO 3: GENERACION DE PORTAFOLIOS
# ==============================

cov_matrix_regions = returns_regions.cov() * 252
cov_matrix_sectors = returns_sectors.cov() * 252

#garantizar que cumpla con el 100% invertido
def constraint_sum_weights():
    return {'type':'eq', 'fun':lambda w: np.sum(w) - 1}


# ==============================
# Portafolio mínima varianza
# ==============================
def minimize_volatility(returns, benchmark, rf_diaria, periodos_año=252):
    # Numero de activos, regiones o sectores
    n_assets = returns.shape[1]

    bounds = tuple((0,1) for _ in range(n_assets))           # NO short selling. Establece los minimos y maximos de cada peso
    x0 = np.ones(n_assets) / n_assets                        # Pesos iniciales iguales

    # Optimización: minimizar volatilidad
    result = op.minimize(
        lambda w: metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_año)["vol_anual"],  # minimize volatility
        x0,
        method='SLSQP',
        constraints=constraint_sum_weights(),
        bounds=bounds
    )

    metricas_opt = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_año)

    return result.x, metricas_opt



# ==============================
# Portafolio máximo retorno
# ==============================
def maximize_return(returns, benchmark, rf_diaria, periodos_año=252):
    # Número de activos
    n_assets = returns.shape[1]

    # Pesos iniciales y límites
    bounds = tuple((0, 1) for _ in range(n_assets))  # no short selling
    x0 = np.ones(n_assets) / n_assets                # pesos iniciales iguales

    # Retorno inicial
    # These lines are not strictly necessary for the optimization but can remain for debugging or initial values.
    retornos_initial = metricas_portafolio(returns, x0, benchmark, rf_diaria, periodos_año)["ret_anual"]
    volatilidad_initial = metricas_portafolio(returns, x0, benchmark, rf_diaria, periodos_año)["vol_anual"]

    # Optimización: maximizar retorno anual
    result = op.minimize(
        lambda w: -metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_año)["ret_anual"],
        x0,
        method='SLSQP',
        constraints=constraint_sum_weights(),
        bounds=bounds
    )

    metricas_opt = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_año)

    return result.x, metricas_opt



# ==============================
# Portafolio máximo Sharpe
# ==============================
def maximize_sharpe(returns, benchmark, rf_diaria, periodos_año=252):
  # Número de activos
  n_assets = returns.shape[1]

  # Pesos iniciales y límites
  bounds = tuple((0, 1) for _ in range(n_assets))  # no short selling
  x0 = np.ones(n_assets) / n_assets                # pesos iniciales iguales

  # Optimización
  result = op.minimize(
      lambda w: -metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_año)["sharpe"], # Pass a callable function
      x0,
      method='SLSQP',
      constraints=constraint_sum_weights(),
      bounds=bounds
  )

  metricas_opt = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_año)

  return result.x, metricas_opt

"""# ==============================
# Frontera eficiente
# ==============================

def efficient_frontier(returns, benchmark, rf_diaria, periodos_año=252, n_points=50):
    n_assets = returns.shape[1]
    x0 = np.ones(n_assets) / n_assets
    bounds = tuple((0, 1) for _ in range(n_assets))

    # Retornos promedio anualizados por activo
    mean_returns = returns.mean() * periodos_año

    frontier_vols = []
    frontier_rets = []

    for tr in np.linspace(mean_returns.min(), mean_returns.max(), n_points):
        # Restricciones: suma de pesos = 1 y retorno = tr
        constraints = [
            constraint_sum_weights(),
            {'type': 'eq', 'fun': lambda w, tr=tr: np.dot(w, mean_returns) - tr}
        ]

        # Minimizar volatilidad para un retorno objetivo
        result = op.minimize(
            lambda w: metricas_portafolio(returns, w, benchmark, rf_diaria, periodos_año)["vol_anual"],
            x0,
            method='SLSQP',
            bounds=bounds,
            constraints=constraints
        )

        if result.success:
            metrics = metricas_portafolio(returns, result.x, benchmark, rf_diaria, periodos_año)
            frontier_vols.append(metrics["vol_anual"])
            frontier_rets.append(tr)

    return np.array(frontier_vols), np.array(frontier_rets)

# ==============================
# Ejecutar optimizaciones
# ==============================
w_min, metrics_min = minimize_volatility(returns_regions, benchmark_regions, rf_diaria)
w_mx, metrics_mx = maximize_return(returns_regions, benchmark_regions, rf_diaria)
w_sharpe, metrics_sharpe = maximize_sharpe(returns_regions, benchmark_regions, rf_diaria)

# Extraer retorno y volatilidad
ret_min = metrics_min["ret_anual"]
vol_min = metrics_min["vol_anual"]

ret_mx = metrics_mx["ret_anual"]
vol_mx = metrics_mx["vol_anual"]

ret_s = metrics_sharpe["ret_anual"]
vol_s = metrics_sharpe["vol_anual"]


# ==============================
# 8. Frontera eficiente
# ==============================
front_vols, front_rets = efficient_frontier(returns_regions, benchmark_regions, rf_diaria, periodos_año=252, n_points=50)

# ==============================
# 9. Gráfico profesional
# ==============================
plt.figure(figsize=(10,6))

# Frontera eficiente
plt.plot(front_vols, front_rets, color='blue', linewidth=2, label="Frontera eficiente", alpha=.8)

# Portafolio mínimo riesgo
plt.scatter(vol_min, ret_min, color='red', s=80, label="Min Var", alpha=.8)

# Portafolio máximo Sharpe
plt.scatter(vol_s, ret_s, color='green', s=80, label="Máximo Sharpe")

# Portafolio máximo retorno
plt.scatter(vol_mx, ret_mx, color='purple', s=80, label="Máximo retorno")

plt.title("Frontera Eficiente - Modelo de Markowitz")
plt.xlabel("Volatilidad")
plt.ylabel("Retorno esperado")
plt.legend()
plt.grid(True)
plt.show()
"""

# ---------------------------
# PASO 4: PORTAFOLIO DEL USUARIO
# ---------------------------


def evaluar_portafolio_usuario():
    """
    Permite al usuario ingresar los pesos de su portafolio para sectores y regiones,
    valida los inputs y calcula las métricas usando metricas_portafolio.
    """
    import numpy as np

    # ---------------------------
    # Instrucciones al usuario
    # ---------------------------
    print("==== Evaluador de Portafolio ====")
    print(f"Debe ingresar {len(universo['sectors']['tickers'])} pesos para SECTORES separados por coma.")
    print(f"Debe ingresar {len(universo['regions']['tickers'])} pesos para REGIONES separados por coma.")
    print("Los pesos deben estar entre 0 y 1 y la suma debe ser 1 para cada portafolio.\n")

    # ---------------------------
    # Input del usuario: sectores
    # ---------------------------
    while True:
        try:
            input_sectores = input("Ingrese los pesos para SECTORES: ")
            w_sectores = np.array([float(x) for x in input_sectores.split(",")])
            if len(w_sectores) != len(universo['sectors']['tickers']):
                raise ValueError("Cantidad de pesos incorrecta.")
            if not np.isclose(np.sum(w_sectores), 1):
                print("⚠️  La suma de los pesos no es 1. Se normalizarán automáticamente.")
                w_sectores = w_sectores / np.sum(w_sectores)
            break
        except Exception as e:
            print("Error:", e, "Intente de nuevo.")

    # ---------------------------
    # Input del usuario: regiones
    # ---------------------------
    while True:
        try:
            input_regiones = input("Ingrese los pesos para REGIONES: ")
            w_regiones = np.array([float(x) for x in input_regiones.split(",")])
            if len(w_regiones) != len(universo['regions']['tickers']):
                raise ValueError("Cantidad de pesos incorrecta.")
            if not np.isclose(np.sum(w_regiones), 1):
                print("⚠️  La suma de los pesos no es 1. Se normalizarán automáticamente.")
                w_regiones = w_regiones / np.sum(w_regiones)
            break
        except Exception as e:
            print("Error:", e, "Intente de nuevo.")

    # ---------------------------
    # Calcular métricas
    # ---------------------------
    metrics_sectores = metricas_portafolio(returns_sectors, w_sectores, benchmark_sectors, rf_diaria, periodos_año)
    metrics_regiones = metricas_portafolio(returns_regions, w_regiones, benchmark_regions, rf_diaria, periodos_año)

    # ---------------------------
    # Mostrar resultados
    # ---------------------------
    print("\n==== Métricas del Portafolio de SECTORES ====")
    for k, v in metrics_sectores.items():
        print(f"{k}: {v:.4f}")

    print("\n==== Métricas del Portafolio de REGIONES ====")
    for k, v in metrics_regiones.items():
        print(f"{k}: {v:.4f}")

evaluar_portafolio_usuario()

"""PASO 5: VISUALIZACION"""

# ================================================================
# ======================   STREAMLIT APP   ========================
# ================================================================

import streamlit as st
import matplotlib.pyplot as plt


# ============================================================
# TÍTULO Y DESCRIPCIÓN
# ============================================================

st.title("Optimización de Portafolio")

st.write("**Regiones utilizadas:** SPLG, EWC, IEUR, EEM, EWJ.")
st.write("**Sectores utilizados:** XLC, XLY, XLP, XLE, XLF, XLV, XLI, XLB, XLRE, XLK, XLU.")

st.markdown("""
Esta app permite comparar portafolios de **regiones** y **sectores**, calculando métricas clave:

- **Volatilidad:** mejor entre menor.
- **Retorno anualizado:** mejor entre mayor.
- **Sharpe ratio:** retorno ajustado al riesgo.
- **Máximo drawdown:** menor indica menor riesgo extremo.
- **Sortino ratio:** Sharpe basado solo en pérdidas.

Selecciona el portafolio y criterio que te interesa y la app mostrará recomendaciones.
""")


# ============================================================
# SELECCIÓN DEL TIPO DE PORTAFOLIO
# ============================================================

tipo = st.selectbox("Selecciona el tipo de portafolio:", ["Regiones", "Sectores"])

if tipo == "Regiones":
    returns = returns_regions
    benchmark = benchmark_regions
    tickers = universo["regions"]["tickers"]
else:
    returns = returns_sectors
    benchmark = benchmark_sectors
    tickers = universo["sectors"]["tickers"]


# ============================================================
# OPTIMIZACIONES (USANDO TUS FUNCIONES)
# ============================================================

w_min_vol, m_min_vol = minimize_volatility(returns, benchmark, rf_diaria)
w_max_ret, m_max_ret = maximize_return(returns, benchmark, rf_diaria)
w_max_sharpe, m_max_sharpe = maximize_sharpe(returns, benchmark, rf_diaria)

nombres = ["Mínima volatilidad", "Máximo retorno", "Máximo Sharpe"]
metricas = [m_min_vol, m_max_ret, m_max_sharpe]


# ============================================================
# GRÁFICA DE LA MÉTRICA SELECCIONADA
# ============================================================

metrica_sel = st.selectbox("Selecciona una métrica para comparar:", list(m_min_vol.keys()))

valores = [m[metrica_sel] for m in metricas]

fig, ax = plt.subplots()
ax.bar(nombres, valores)
ax.set_ylabel(metrica_sel)
ax.set_title(f"Comparación de {metrica_sel}")

st.pyplot(fig)


# ============================================================
# RECOMENDACIÓN DEL MEJOR PORTAFOLIO
# ============================================================

if metrica_sel in ["vol_anual", "max_drawdown", "VaR_95", "CVaR_95"]:
    idx = np.argmin(valores)
    criterio = "menor es mejor"
else:
    idx = np.argmax(valores)
    criterio = "mayor es mejor"

st.success(f"Para la métrica **{metrica_sel}** ({criterio}), el mejor portafolio es: **{nombres[idx]}**")


# ============================================================
# SECCIÓN: PORTAFOLIO DEL USUARIO
# =======

